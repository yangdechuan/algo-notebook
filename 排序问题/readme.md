# 基于关键词比较的排序
## 快速排序
数组A[l, r]被划分为两个（可能为空）子数组A[l, q-1]和A[q+1, r]，
使得A[l, q-1]中每一个元素都小于等于A[q]，而A[q]也小于等于A[q+1, r]中的每个元素。
递归地在每个子数组继续进行上述过程。

## 堆排序
将输入数组建成小根堆，每次弹出堆顶元素。

## 归并排序
递归地对左右两个子序列进行归并排序，然后将两个有序序列归并起来，得到完全有序的序列。

|  | 期望时间复杂性 |最坏时间复杂性|最好时间复杂性| 是否稳定 |
:- | :-: | :-: |:-: |:-: |
| 快速排序 | O(nlogn) |O(n^2) |O(nlogn) | 不稳定 |
| 归并排序 | O(nlogn) |O(nlogn) |O(nlogn) | 稳定  |
| 堆排序   | O(nlogn) |O(nlogn) |O(nlogn) | 不稳定 |
|插入排序   | O(n^2) |O(n^2) |O(n) | 稳定 |
| 冒泡排序   | O(n^2) |O(n^2) |O(n) | 稳定 |
| 选择排序  | O(n^2) |O(n^2) |O(n^2) | 不稳定 |

# 非基于关键词比较的排序
当知道待排序关键词的更多知识时，例如分布的范围，就能构造出非基于关键词比较的排序算法，而且能在最坏情况下达到线性时间。
## 计数排序
对每一个输入元素x，确定小于x的元素个数，利用这一信息，就可以直接把x放在它的输出数组的位置上。

## 基数排序
先按最低位有效位进行排序，再按照次低位有效位进行排序，以此类推。

## 桶排序（分布排序）
假设输入服从均匀分布；
将值分布区间划分为n个相同大小的子区间（称为桶），然后将n个输入数分别放到各个桶中，因为输入数据是均匀的，所以一般不会出现多个数据落在同一个桶中的情况；先对每个桶中的数进行排序，然后遍历每个桶，按照次序把每个桶中元素列出来即可。